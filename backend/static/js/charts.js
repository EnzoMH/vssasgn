// Ï∞®Ìä∏ Í¥ÄÎ¶¨ ÌÅ¥ÎûòÏä§
class ChartManager {
  constructor() {
    this.charts = {};
    this.isDarkMode = false;
    this.colors = {
      primary: "#3b82f6",
      secondary: "#10b981",
      warning: "#f59e0b",
      danger: "#ef4444",
      gray: "#6b7280",
    };

    // Îã§ÌÅ¨Î™®Îìú ÌÖåÎßà ÏÑ§Ï†ï
    this.lightTheme = {
      textColor: "#1f2937",
      gridColor: "#e5e7eb",
      backgroundColor: "#ffffff",
      backgroundColorSecondary: "#f9fafb",
    };

    this.darkTheme = {
      textColor: "#f9fafb",
      gridColor: "#374151",
      backgroundColor: "#1f2937",
      backgroundColorSecondary: "#111827",
    };

    this.bindThemeEvents();
  }

  // ÌÖåÎßà Ïù¥Î≤§Ìä∏ Î∞îÏù∏Îî©
  bindThemeEvents() {
    // ÌÖåÎßà Î≥ÄÍ≤Ω Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
    window.addEventListener("themechange", (e) => {
      this.setTheme(e.detail.theme);
    });

    // Ï¥àÍ∏∞ ÌÖåÎßà Í∞êÏßÄ
    this.detectInitialTheme();
  }

  // Ï¥àÍ∏∞ ÌÖåÎßà Í∞êÏßÄ
  detectInitialTheme() {
    const theme =
      document.documentElement.getAttribute("data-theme") || "light";
    this.setTheme(theme);
  }

  // ÌÖåÎßà ÏÑ§Ï†ï
  setTheme(theme) {
    this.isDarkMode = theme === "dark";
    this.updateChartDefaults();
    this.updateExistingCharts();
  }

  // Chart.js Í∏∞Î≥∏Í∞í ÏóÖÎç∞Ïù¥Ìä∏
  updateChartDefaults() {
    if (!window.Chart) return;

    const currentTheme = this.getCurrentTheme();

    // Chart.js Í∏ÄÎ°úÎ≤å Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï (v3+ Ìò∏Ìôò)
    Chart.defaults.color = currentTheme.textColor;
    Chart.defaults.borderColor = currentTheme.gridColor;
    Chart.defaults.backgroundColor = currentTheme.backgroundColor;

    // ÌîåÎü¨Í∑∏Ïù∏ Í∏∞Î≥∏Í∞í (ÏïàÏ†ÑÌïú ÏÑ§Ï†ï)
    if (!Chart.defaults.plugins) Chart.defaults.plugins = {};
    if (!Chart.defaults.plugins.legend) Chart.defaults.plugins.legend = {};
    if (!Chart.defaults.plugins.legend.labels)
      Chart.defaults.plugins.legend.labels = {};
    if (!Chart.defaults.plugins.tooltip) Chart.defaults.plugins.tooltip = {};

    Chart.defaults.plugins.legend.labels.color = currentTheme.textColor;
    Chart.defaults.plugins.tooltip.backgroundColor =
      currentTheme.backgroundColor;
    Chart.defaults.plugins.tooltip.titleColor = currentTheme.textColor;
    Chart.defaults.plugins.tooltip.bodyColor = currentTheme.textColor;
  }

  // Í∏∞Ï°¥ Ï∞®Ìä∏Îì§Ïùò ÌÖåÎßàÎßå ÏóÖÎç∞Ïù¥Ìä∏
  updateExistingCharts() {
    Object.keys(this.charts).forEach((chartId) => {
      const chart = this.charts[chartId];
      if (chart && chart.update) {
        this.updateChartTheme(chart);
      }
    });
  }

  // Î™®Îì† Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏ (Îç∞Ïù¥ÌÑ∞ Ìè¨Ìï®)
  updateAllCharts() {
    this.updateExistingCharts();
  }

  // Í∞úÎ≥Ñ Ï∞®Ìä∏ ÌÖåÎßà ÏóÖÎç∞Ïù¥Ìä∏
  updateChartTheme(chart) {
    const currentTheme = this.getCurrentTheme();

    // Ïä§ÏºÄÏùº ÏÉâÏÉÅ ÏóÖÎç∞Ïù¥Ìä∏
    if (chart.options.scales) {
      Object.keys(chart.options.scales).forEach((scaleId) => {
        const scale = chart.options.scales[scaleId];
        if (scale.ticks) {
          scale.ticks.color = currentTheme.textColor;
        }
        if (scale.grid) {
          scale.grid.color = currentTheme.gridColor;
        }
      });
    }

    // Î≤îÎ°Ä ÏÉâÏÉÅ ÏóÖÎç∞Ïù¥Ìä∏
    if (chart.options.plugins && chart.options.plugins.legend) {
      chart.options.plugins.legend.labels.color = currentTheme.textColor;
    }

    // Ìà¥ÌåÅ ÏÉâÏÉÅ ÏóÖÎç∞Ïù¥Ìä∏
    if (chart.options.plugins && chart.options.plugins.tooltip) {
      chart.options.plugins.tooltip.backgroundColor =
        currentTheme.backgroundColor;
      chart.options.plugins.tooltip.titleColor = currentTheme.textColor;
      chart.options.plugins.tooltip.bodyColor = currentTheme.textColor;
    }

    // Îç∞Ïù¥ÌÑ∞ÏÖã ÏÉâÏÉÅ ÏóÖÎç∞Ïù¥Ìä∏ (ÌïÑÏöîÌïú Í≤ΩÏö∞)
    if (chart.data.datasets) {
      chart.data.datasets.forEach((dataset) => {
        // Î≥¥Ï°∞ ÏÉâÏÉÅÎì§Îßå ÌÖåÎßàÏóê Îî∞Îùº Î≥ÄÍ≤Ω
        if (
          dataset.backgroundColor === "#e5e7eb" ||
          dataset.backgroundColor === "#374151"
        ) {
          dataset.backgroundColor = this.isDarkMode ? "#374151" : "#e5e7eb";
        }
        if (
          dataset.borderColor === "#d1d5db" ||
          dataset.borderColor === "#4b5563"
        ) {
          dataset.borderColor = this.isDarkMode ? "#4b5563" : "#d1d5db";
        }
      });
    }

    chart.update("none");
  }

  // ÌòÑÏû¨ ÌÖåÎßà Í∞ÄÏ†∏Ïò§Í∏∞
  getCurrentTheme() {
    return this.isDarkMode ? this.darkTheme : this.lightTheme;
  }

  // ÌÖåÎßàÎ≥Ñ ÏòµÏÖò ÏÉùÏÑ±
  getThemedOptions(baseOptions = {}) {
    const currentTheme = this.getCurrentTheme();

    const themedOptions = {
      ...baseOptions,
      plugins: {
        ...baseOptions.plugins,
        legend: {
          ...baseOptions.plugins?.legend,
          labels: {
            ...baseOptions.plugins?.legend?.labels,
            color: currentTheme.textColor,
          },
        },
        tooltip: {
          ...baseOptions.plugins?.tooltip,
          backgroundColor: currentTheme.backgroundColor,
          titleColor: currentTheme.textColor,
          bodyColor: currentTheme.textColor,
          borderColor: currentTheme.gridColor,
          borderWidth: 1,
        },
      },
      scales: {
        ...baseOptions.scales,
      },
    };

    // Ïä§ÏºÄÏùº ÌÖåÎßà Ï†ÅÏö©
    if (themedOptions.scales) {
      Object.keys(themedOptions.scales).forEach((scaleId) => {
        const scale = themedOptions.scales[scaleId];
        themedOptions.scales[scaleId] = {
          ...scale,
          ticks: {
            ...scale.ticks,
            color: currentTheme.textColor,
          },
          grid: {
            ...scale.grid,
            color: currentTheme.gridColor,
          },
        };
      });
    }

    return themedOptions;
  }

  // Î™®Îì† Ï∞®Ìä∏ Î¶¨ÏÇ¨Ïù¥Ï¶à
  resizeCharts() {
    Object.keys(this.charts).forEach((chartId) => {
      const chart = this.charts[chartId];
      if (chart && chart.resize) {
        chart.resize();
      }
    });
  }

  // Ï∞®Ìä∏ Ïù∏Ïä§ÌÑ¥Ïä§ Ï†ÄÏû•
  setChart(id, chart) {
    if (this.charts[id]) {
      this.charts[id].destroy();
    }
    this.charts[id] = chart;
  }

  // ÎûôÎ≥Ñ Ïû¨Í≥† ÌòÑÌô© Î∞î Ï∞®Ìä∏ (Ïã§Ï†ú rawdata Í∏∞Î∞ò)
  createInventoryChart(data, canvasId = "inventoryChart") {
    console.log("üì¶ Ïû¨Í≥† Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞:", data);

    const ctx = document.getElementById(canvasId);
    if (!ctx) return;

    const currentTheme = this.getCurrentTheme();

    const baseOptions = {
      responsive: true,
      maintainAspectRatio: false,
      aspectRatio: 2,
      plugins: {
        title: {
          display: false,
        },
        legend: {
          position: "top",
        },
        tooltip: {
          callbacks: {
            label: function (context) {
              return `${context.dataset.label}: ${NumberUtils.formatNumber(
                context.parsed.y
              )}Í∞ú`;
            },
          },
        },
      },
      scales: {
        y: {
          beginAtZero: true,
          max: function (context) {
            const max = Math.max(
              ...context.chart.data.datasets.flatMap((dataset) => dataset.data)
            );
            return Math.ceil(max * 1.2);
          },
          ticks: {
            callback: function (value) {
              return NumberUtils.formatNumber(value);
            },
            maxTicksLimit: 8,
          },
        },
      },
      layout: {
        padding: 10,
      },
    };

    const chart = new Chart(ctx, {
      type: "bar",
      data: {
        labels: data.map((item) => item.rackName),
        datasets: [
          {
            label: "ÌòÑÏû¨ Ïû¨Í≥†",
            data: data.map((item) => item.currentStock),
            backgroundColor: this.colors.primary,
            borderColor: this.colors.primary,
            borderWidth: 1,
            borderRadius: 4,
          },
          {
            label: "ÏµúÎåÄ Ïö©Îüâ",
            data: data.map((item) => item.capacity),
            backgroundColor: this.isDarkMode ? "#374151" : "#e5e7eb",
            borderColor: this.isDarkMode ? "#4b5563" : "#d1d5db",
            borderWidth: 1,
            borderRadius: 4,
          },
        ],
      },
      options: this.getThemedOptions(baseOptions),
    });

    this.setChart(canvasId, chart);
    return chart;
  }

  // ÏùºÎ≥Ñ ÏûÖÏ∂úÍ≥† Ìä∏Î†åÎìú ÎùºÏù∏ Ï∞®Ìä∏
  createTrendChart(data, canvasId = "trendChart") {
    console.log("üìà Ìä∏Î†åÎìú Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞:", data);

    const ctx = document.getElementById(canvasId);
    if (!ctx) return;

    const chart = new Chart(ctx, {
      type: "line",
      data: {
        labels: data.map((item) => DateUtils.formatDate(item.date)),
        datasets: [
          {
            label: "ÏûÖÍ≥†Îüâ",
            data: data.map((item) => item.inbound || 0),
            borderColor: this.colors.secondary,
            backgroundColor: this.colors.secondary + "20",
            borderWidth: 3,
            fill: false,
            tension: 0.1,
            pointBackgroundColor: this.colors.secondary,
            pointBorderColor: "#ffffff",
            pointBorderWidth: 2,
            pointRadius: 6,
          },
          {
            label: "Ï∂úÍ≥†Îüâ",
            data: data.map((item) => item.outbound || 0),
            borderColor: this.colors.danger,
            backgroundColor: this.colors.danger + "20",
            borderWidth: 3,
            fill: false,
            tension: 0.1,
            pointBackgroundColor: this.colors.danger,
            pointBorderColor: "#ffffff",
            pointBorderWidth: 2,
            pointRadius: 6,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        aspectRatio: 2, // Î™ÖÏãúÏ†Å ÎπÑÏú® ÏÑ§Ï†ï
        plugins: {
          legend: {
            position: "top",
          },
          tooltip: {
            callbacks: {
              label: function (context) {
                return `${context.dataset.label}: ${NumberUtils.formatNumber(
                  context.parsed.y
                )}Í±¥`;
              },
            },
          },
        },
        scales: {
          y: {
            beginAtZero: true,
            max: function (context) {
              // YÏ∂ï ÏµúÎåÄÍ∞íÏùÑ Îç∞Ïù¥ÌÑ∞ ÏµúÎåÄÍ∞íÏùò 1.2Î∞∞Î°ú Ï†úÌïú
              const max = Math.max(
                ...context.chart.data.datasets.flatMap(
                  (dataset) => dataset.data
                )
              );
              return Math.ceil(max * 1.2);
            },
            ticks: {
              callback: function (value) {
                return NumberUtils.formatNumber(value);
              },
              maxTicksLimit: 8, // ÏµúÎåÄ Ìã± Í∞úÏàò Ï†úÌïú
            },
          },
        },
        interaction: {
          intersect: false,
          mode: "index",
        },
        layout: {
          padding: 10,
        },
      },
    });

    this.setChart(canvasId, chart);
    return chart;
  }

  // Ï†úÌíà Ïπ¥ÌÖåÍ≥†Î¶¨ Î∂ÑÌè¨ ÌååÏù¥ Ï∞®Ìä∏ (Ïã§Ï†ú rawdata Í∏∞Î∞ò)
  createCategoryChart(data, canvasId = "categoryChart") {
    console.log("üìä Ïπ¥ÌÖåÍ≥†Î¶¨ Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞:", data);

    const ctx = document.getElementById(canvasId);
    if (!ctx) return;

    // ÏÉâÏÉÅ Î∞∞Ïó¥ ÏÉùÏÑ±
    const backgroundColors = [
      this.colors.primary,
      this.colors.secondary,
      this.colors.warning,
      this.colors.danger,
      "#8b5cf6",
      "#f97316",
      "#06b6d4",
      "#84cc16",
    ];

    const chart = new Chart(ctx, {
      type: "doughnut",
      data: {
        labels: data.map((item) => item.name),
        datasets: [
          {
            data: data.map((item) => item.value),
            backgroundColor: backgroundColors.slice(0, data.length),
            borderWidth: 2,
            borderColor: "#ffffff",
            hoverBorderWidth: 3,
            hoverBorderColor: "#ffffff",
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: "right",
            labels: {
              usePointStyle: true,
              padding: 20,
            },
          },
          tooltip: {
            callbacks: {
              label: function (context) {
                const total = context.dataset.data.reduce((a, b) => a + b, 0);
                const percentage = ((context.parsed / total) * 100).toFixed(1);
                return `${context.label}: ${NumberUtils.formatNumber(
                  context.parsed
                )}Í∞ú (${percentage}%)`;
              },
            },
          },
        },
        cutout: "50%",
      },
    });

    this.setChart(canvasId, chart);
    return chart;
  }

  // ML Í≤∞Í≥ºÎ•º ÏúÑÌïú Î∞î Ï∞®Ìä∏ (ÏàòÏöî ÏòàÏ∏° Îì±)
  createMLResultChart(data, type) {
    const container = document.getElementById("mlResults");
    if (!container) return;

    // Í∏∞Ï°¥ Ï∞®Ìä∏ Ï†úÍ±∞
    container.innerHTML = "";

    if (type === "demand") {
      this.createDemandPredictionChart(container, data);
    } else if (type === "cluster") {
      this.createClusterAnalysisChart(container, data);
    } else if (type === "anomaly") {
      this.createAnomalyDetectionChart(container, data);
    }
  }

  // ÏàòÏöî ÏòàÏ∏° Ï∞®Ìä∏
  createDemandPredictionChart(container, data) {
    const canvas = document.createElement("canvas");
    canvas.id = "demandChart";
    container.appendChild(canvas);

    const chart = new Chart(canvas, {
      type: "bar",
      data: {
        labels: ["ÏòàÏ∏° ÏàòÏöîÎüâ"],
        datasets: [
          {
            label: "ÏòàÏ∏°Í∞í",
            data: data.prediction || [0],
            backgroundColor: this.colors.warning,
            borderColor: this.colors.warning,
            borderWidth: 1,
            borderRadius: 4,
          },
        ],
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false,
          },
          tooltip: {
            callbacks: {
              label: function (context) {
                return `ÏòàÏ∏° ÏàòÏöîÎüâ: ${NumberUtils.formatNumber(
                  context.parsed.y
                )}Í∞ú`;
              },
            },
          },
        },
        scales: {
          y: {
            beginAtZero: true,
            ticks: {
              callback: function (value) {
                return NumberUtils.formatNumber(value);
              },
            },
          },
        },
      },
    });

    this.setChart("demand", chart);
  }

  // ÌÅ¥Îü¨Ïä§ÌÑ∞ Î∂ÑÏÑù Ï∞®Ìä∏
  createClusterAnalysisChart(container, data) {
    const chartDiv = document.createElement("div");
    chartDiv.innerHTML = `
            <h4><i class="fas fa-layer-group"></i> Ï†úÌíà ÌÅ¥Îü¨Ïä§ÌÑ∞ÎßÅ Í≤∞Í≥º</h4>
            <div class="cluster-results">
                ${
                  data.clusters
                    ? data.clusters
                        .map(
                          (cluster, index) => `
                    <div class="cluster-item">
                        <span class="cluster-badge" style="background-color: ${this.getClusterColor(
                          cluster
                        )}">
                            ÌÅ¥Îü¨Ïä§ÌÑ∞ ${cluster}
                        </span>
                        <span>Ï†úÌíà ${index + 1}</span>
                    </div>
                `
                        )
                        .join("")
                    : "<p>ÌÅ¥Îü¨Ïä§ÌÑ∞ÎßÅ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.</p>"
                }
            </div>
        `;
    container.appendChild(chartDiv);

    // ÌÅ¥Îü¨Ïä§ÌÑ∞ Í≤∞Í≥º Ïä§ÌÉÄÏùº
    const style = document.createElement("style");
    style.textContent = `
            .cluster-results {
                display: flex;
                flex-wrap: wrap;
                gap: 0.5rem;
                margin-top: 1rem;
            }
            .cluster-item {
                display: flex;
                align-items: center;
                gap: 0.5rem;
                padding: 0.5rem;
                background-color: var(--gray-100);
                border-radius: var(--border-radius-sm);
            }
            .cluster-badge {
                padding: 0.25rem 0.5rem;
                border-radius: var(--border-radius-sm);
                color: white;
                font-size: 0.75rem;
                font-weight: 500;
            }
        `;
    if (!document.querySelector("#clusterStyles")) {
      style.id = "clusterStyles";
      document.head.appendChild(style);
    }
  }

  // Ïù¥ÏÉÅ ÌÉêÏßÄ Ï∞®Ìä∏
  createAnomalyDetectionChart(container, data) {
    const chartDiv = document.createElement("div");
    chartDiv.innerHTML = `
            <h4><i class="fas fa-exclamation-triangle"></i> Ïù¥ÏÉÅ ÌÉêÏßÄ Í≤∞Í≥º</h4>
            <div class="anomaly-results">
                ${
                  data.anomalies && data.anomalies.length > 0
                    ? `
                    <div class="anomaly-summary">
                        <span class="anomaly-count">${
                          data.anomalies.length
                        }Í∞úÏùò Ïù¥ÏÉÅ ÏßïÌõÑ Î∞úÍ≤¨</span>
                    </div>
                    <div class="anomaly-list">
                        ${data.anomalies
                          .slice(0, 5)
                          .map(
                            (anomaly, index) => `
                            <div class="anomaly-item">
                                <i class="fas fa-warning" style="color: var(--danger);"></i>
                                <span>Ïù¥ÏÉÅ Îç∞Ïù¥ÌÑ∞ ${index + 1}</span>
                                <span class="anomaly-score">Ï†êÏàò: ${NumberUtils.formatDecimal(
                                  anomaly.score || Math.random(),
                                  2
                                )}</span>
                            </div>
                        `
                          )
                          .join("")}
                    </div>
                `
                    : '<p style="color: var(--secondary);"><i class="fas fa-check-circle"></i> Ïù¥ÏÉÅ ÏßïÌõÑÍ∞Ä Î∞úÍ≤¨ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.</p>'
                }
            </div>
        `;
    container.appendChild(chartDiv);

    // Ïù¥ÏÉÅ ÌÉêÏßÄ Í≤∞Í≥º Ïä§ÌÉÄÏùº
    const style = document.createElement("style");
    style.textContent = `
            .anomaly-summary {
                padding: 1rem;
                background-color: var(--danger);
                color: white;
                border-radius: var(--border-radius-sm);
                margin-bottom: 1rem;
                text-align: center;
            }
            .anomaly-count {
                font-weight: 600;
            }
            .anomaly-list {
                display: flex;
                flex-direction: column;
                gap: 0.5rem;
            }
            .anomaly-item {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 0.75rem;
                background-color: var(--gray-100);
                border-radius: var(--border-radius-sm);
                border-left: 4px solid var(--danger);
            }
            .anomaly-score {
                font-size: 0.875rem;
                color: var(--gray-500);
            }
        `;
    if (!document.querySelector("#anomalyStyles")) {
      style.id = "anomalyStyles";
      document.head.appendChild(style);
    }
  }

  // ÌÅ¥Îü¨Ïä§ÌÑ∞ ÏÉâÏÉÅ Í∞ÄÏ†∏Ïò§Í∏∞
  getClusterColor(cluster) {
    const colors = [
      this.colors.primary,
      this.colors.secondary,
      this.colors.warning,
      this.colors.danger,
    ];
    return colors[cluster % colors.length];
  }

  // Î™®Îì† Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
  updateAllCharts(dashboardData) {
    try {
      if (dashboardData.inventoryData) {
        this.createInventoryChart(dashboardData.inventoryData);
      }
      if (dashboardData.trendData) {
        this.createTrendChart(dashboardData.trendData);
      }
      if (dashboardData.categoryData) {
        this.createCategoryChart(dashboardData.categoryData);
      }
    } catch (error) {
      console.error("Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò:", error);
      NotificationManager.error("Ï∞®Ìä∏Î•º ÏóÖÎç∞Ïù¥Ìä∏ÌïòÎäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
    }
  }

  // Ï∞®Ìä∏ ÌÅ¨Í∏∞ Ï°∞Ï†ï
  resizeCharts() {
    Object.values(this.charts).forEach((chart) => {
      if (chart && typeof chart.resize === "function") {
        chart.resize();
      }
    });
  }

  // Î™®Îì† Ï∞®Ìä∏ Ï†úÍ±∞
  destroyAllCharts() {
    Object.values(this.charts).forEach((chart) => {
      if (chart && typeof chart.destroy === "function") {
        chart.destroy();
      }
    });
    this.charts = {};
  }

  // LLMÏùÑ ÌôúÏö©Ìïú Ï∞®Ìä∏ ÏÉùÏÑ±
  async generateAIChart(userRequest, containerId = "aiGeneratedChart") {
    try {
      // Î°úÎî© ÏÉÅÌÉú ÌëúÏãú
      this.showChartLoading(containerId);

      console.log(`ü§ñ AI Ï∞®Ìä∏ ÏÉùÏÑ± ÏöîÏ≤≠: ${userRequest}`);

      // API Ìò∏Ï∂ú
      const response = await fetch("/api/ai/generate-chart", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          user_request: userRequest,
          context: "",
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const result = await response.json();

      // Î°úÎî© ÏÉÅÌÉú Ï†úÍ±∞
      this.hideChartLoading(containerId);

      if (result.success || result.chart_config) {
        const chartConfig = result.chart_config;
        console.log("‚úÖ AI Ï∞®Ìä∏ ÏÑ§Ï†ï ÏàòÏã†:", chartConfig);

        // Ï∞®Ìä∏ ÏÉùÏÑ±
        const chart = this.createDynamicChart(containerId, chartConfig);

        if (chart) {
          // ÏÑ±Í≥µ Î©îÏãúÏßÄ ÌëúÏãú
          if (!result.success) {
            NotificationManager.warning(
              `Ï∞®Ìä∏Î•º ÏÉùÏÑ±ÌñàÏßÄÎßå ÏùºÎ∂Ä Î¨∏Ï†úÍ∞Ä ÏûàÏóàÏäµÎãàÎã§: ${result.message}`
            );
          } else {
            NotificationManager.success("AIÍ∞Ä Ï∞®Ìä∏Î•º ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÉùÏÑ±ÌñàÏäµÎãàÎã§!");
          }

          return {
            success: true,
            chart: chart,
            config: chartConfig,
            message: result.message,
          };
        } else {
          throw new Error("Ï∞®Ìä∏ ÏÉùÏÑ±Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§");
        }
      } else {
        throw new Error(result.error || result.message || "Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò");
      }
    } catch (error) {
      console.error("‚ùå AI Ï∞®Ìä∏ ÏÉùÏÑ± Ïò§Î•ò:", error);
      this.hideChartLoading(containerId);
      this.showChartError(containerId, error.message);
      NotificationManager.error(`AI Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®: ${error.message}`);

      return {
        success: false,
        error: error.message,
      };
    }
  }

  // ÎèôÏ†Å Ï∞®Ìä∏ ÏÉùÏÑ± (AIÍ∞Ä ÏÉùÏÑ±Ìïú ÏÑ§Ï†ï ÏÇ¨Ïö©)
  createDynamicChart(containerId, chartConfig) {
    try {
      const canvas = document.getElementById(containerId);
      if (!canvas) {
        console.error(`Ï∞®Ìä∏ Ïª®ÌÖåÏù¥ÎÑàÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§: ${containerId}`);
        return null;
      }

      // Í∏∞Ï°¥ Ï∞®Ìä∏Í∞Ä ÏûàÎã§Î©¥ Ï†úÍ±∞
      if (this.charts[containerId]) {
        this.charts[containerId].destroy();
      }

      // Chart.js ÏÑ§Ï†ï ÏÉùÏÑ± (ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞í Ï†ÅÏö©)
      const safeOptions = {
        responsive: true,
        maintainAspectRatio: false,
        aspectRatio: 2, // Î™ÖÏãúÏ†Å ÎπÑÏú® ÏÑ§Ï†ï
        layout: {
          padding: 10,
        },
        ...chartConfig.options,
      };

      // YÏ∂ï Ïä§ÏºÄÏùºÏóê ÏïàÏ†ÑÌïú Ï†úÌïú Ï∂îÍ∞Ä
      if (safeOptions.scales && safeOptions.scales.y) {
        safeOptions.scales.y = {
          beginAtZero: true,
          maxTicksLimit: 8,
          ...safeOptions.scales.y,
        };
      } else if (
        chartConfig.chart_type !== "pie" &&
        chartConfig.chart_type !== "doughnut"
      ) {
        safeOptions.scales = {
          y: {
            beginAtZero: true,
            maxTicksLimit: 8,
            ticks: {
              callback: function (value) {
                return typeof value === "number"
                  ? value.toLocaleString()
                  : value;
              },
            },
          },
          ...safeOptions.scales,
        };
      }

      const config = {
        type: chartConfig.chart_type,
        data: chartConfig.data,
        options: safeOptions,
      };

      // Ï∞®Ìä∏ ÏÉùÏÑ±
      const chart = new Chart(canvas, config);
      this.setChart(containerId, chart);

      console.log(
        `‚úÖ ÎèôÏ†Å Ï∞®Ìä∏ ÏÉùÏÑ± ÏôÑÎ£å: ${chartConfig.chart_type} - ${chartConfig.title}`
      );
      return chart;
    } catch (error) {
      console.error("ÎèôÏ†Å Ï∞®Ìä∏ ÏÉùÏÑ± Ïò§Î•ò:", error);
      return null;
    }
  }

  // Ï∞®Ìä∏ Î°úÎî© ÏÉÅÌÉú ÌëúÏãú
  showChartLoading(containerId) {
    const container = document.getElementById(containerId);
    if (container) {
      container.style.position = "relative";
      container.innerHTML = `
        <div class="chart-loading" style="
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          text-align: center;
          z-index: 1000;
        ">
          <div class="spinner-border text-primary" role="status" style="width: 3rem; height: 3rem;">
            <span class="visually-hidden">Î°úÎî©Ï§ë...</span>
          </div>
          <div class="mt-2 text-muted">AIÍ∞Ä Ï∞®Ìä∏Î•º ÏÉùÏÑ±ÌïòÍ≥† ÏûàÏäµÎãàÎã§...</div>
        </div>
      `;
    }
  }

  // Ï∞®Ìä∏ Î°úÎî© ÏÉÅÌÉú Ï†úÍ±∞
  hideChartLoading(containerId) {
    const container = document.getElementById(containerId);
    if (container) {
      const loading = container.querySelector(".chart-loading");
      if (loading) {
        loading.remove();
      }
    }
  }

  // Ï∞®Ìä∏ Ïò§Î•ò ÌëúÏãú
  showChartError(containerId, errorMessage) {
    const container = document.getElementById(containerId);
    if (container) {
      container.innerHTML = `
        <div class="chart-error text-center p-4" style="color: #dc3545;">
          <i class="fas fa-exclamation-triangle fa-2x mb-2"></i>
          <div class="fw-bold">Ï∞®Ìä∏ ÏÉùÏÑ± Ïã§Ìå®</div>
          <div class="small text-muted mt-1">${errorMessage}</div>
          <button class="btn btn-outline-primary btn-sm mt-2" onclick="location.reload()">
            Îã§Ïãú ÏãúÎèÑ
          </button>
        </div>
      `;
    }
  }
}

// Ï∞®Ìä∏ Îß§ÎãàÏ†ÄÎäî dashboard.jsÏóêÏÑú Ï¥àÍ∏∞ÌôîÎê®
